(define (my-eval exp env)
  (cond ((immediate-data? exp) exp)
	((variable? exp) (lookup-variable exp env))
	((quote? exp) (cadr exp))
	((assignment? exp) (set-variable (set-name exp) (set-value exp) env))
	((define? exp) (define-variable (define-name exp) (define-value exp env) env))
	((if? exp) (eval-if exp env))
	((lambda? exp) (eval-lambda exp env))
	((application? exp) 
	 (my-apply (my-eval (car exp) env)
		   (make-args (cdr exp) env)))
	(else (display "known error"))))

(define (immediate-data? exp)
  (or (number? exp) (string? exp) (boolean? exp)))
(define (variable? exp)
  (symbol? exp))
(define (make-binding name value)
  (cons name value))
(define (lookup-variable-in-frame variable frame)
  (if (null? frame)
      '()
      (if (eq? (caar frame) variable)
	  (cdar frame)
	  (lookup-variable-in-frame variable (cdr frame)))))
(define (lookup-variable variable env)
  (if (null? env)
      '()
      (let ((ret (lookup-variable-in-frame variable (car env))))
      (if (null? ret)
	  (lookup-variable variable (cdr env))
	  ret))))
(define (quote? exp)
  (tagged-list? exp 'quote))
(define (tagged-list? exp tag)
  (and (pair? exp) (eq? (car exp) tag)))
(define (define? exp)
  (tagged-list? exp 'define))
(define (define-name exp)
  (cadr exp))
(define (define-value exp env)
  (my-eval (caddr exp) env))
(define (lookup-binding-in-frame frame name)
  (if (null? frame)
      '()
      (if (eq? (caar frame) name)
	  (car frame)
	  (lookup-binding-in-frame (cdr frame) name))))
(define (define-variable name value env)
  (let ((binding (lookup-binding-in-frame (car env) name)))
    (if (null? binding)
	(set-car! env (cons (make-binding name value) (car env)))
	(set-cdr! binding value))))
(define (set-variable name value env)
  (if (null? env)
      (display "error:variable not exist")
      (let ((binding (lookup-binding-in-frame (car env) name)))
	(if (null? binding)
	    (set-variable name value (cdr env))
	    (set-cdr! binding value)))))
      
(define (tagged-list? exp tag)
  (and (pair? exp) (eq? (car exp) tag)))
	  
(define (assignment? exp)
  (tagged-list? exp 'set!))
(define (set-name exp)
  (cadr exp))
(define (set-value exp)
  (caddr exp))
(define (if? exp)
  (tagged-list? exp 'if))
(define (eval-if exp env)
  (let ((if-part (cadr exp)) 
	(then-part (caddr exp))
	(else-part (cadddr exp)))
    (if (my-eval if-part env)
	(my-eval then-part env)
	(my-eval else-part env))))
(define (lambda? exp)
  (tagged-list? exp 'lambda))
(define (eval-lambda exp env)
  (let ((arg-part (cadr exp)) (body-part (caddr exp)))
    (list 'procedure arg-part body-part env)))
(define (application? exp) (pair? exp))
(define (make-args list env)
  (if (null? list)
      '()
      (cons (my-eval (car list) env)
	    (make-args (cdr list) env))))
(define (my-apply procedure argument)
  (cond ((tagged-list? procedure 'procedure) (call-procedure (cdr procedure) argument))
	((tagged-list? procedure 'primitive) (call-primitive (cadr procedure) argument))
	(else (display "error:undefined procedure"))))
(define (call-procedure procedure argument)
  (let ((parament (car procedure))
	(body (cadr procedure))
	(env (caddr procedure))
	(newframe '()))
    (define (make-frame names values newframe)
      (cond ((and (null? names) (null? values)) newframe)
	    ((or (null? names) (null? values)) (display "wrong number of args"))
	    (else (cons
		   (make-binding (car names) (car values))
		   (make-frame (cdr names) (cdr values) newframe)))))
    (begin (set! env (cons (make-frame parament argument newframe) env))
	   (my-eval body env))))
(define (call-primitive op argument)
    (op (car argument) (cadr argument)))
(define env '())
(define global-frame '())
(define (init-env)
  (begin (set! global-frame (cons (make-binding '+ (list 'primitive +)) global-frame))
	 (set! global-frame (cons (make-binding '- (list 'primitive -)) global-frame))
	 (set! global-frame (cons (make-binding '/ (list 'primitive /)) global-frame))
	 (set! global-frame (cons (make-binding '* (list 'primitive *)) global-frame))
	 (set! env (cons global-frame '()))))
    
	
(define (repl evaluator env)
  (display "repl>")
  (let ((expr (read)))
    (cond ((eof-object? expr)
	   (display "byebye")
	   (newline))
	  (else
	   (write (evaluator expr env))
	   (newline)
	   (repl evaluator)))))