1.对象类型系统
scheme中类型是与值相关联的。变量是无类型的，但变量绑定的值是有类型的。
2.环境
在程序的某一点有效的所有可见绑定的集合，被称为对该点有效的环境。
3.内存管理
4.垃圾回收
5.文法分析
6.编译
6.1计算栈而非通用栈
6.2严格尾递归
如果scheme实现上支持无限数量的活动尾调用，它就是严格尾递归的。
尾调用是发生在尾上下文中的过程调用。
尾上下文定义具体见r5rs第8页
7.虚拟机


写个专题，每天记录遇到了哪些问题，怎么样解决这些问题的。
2011.9.5以前
垃圾回收的问题
参数绑定的问题

2011.9.5
1.尾调用的实现
理解尾上下文，尾调用。
2.发现递归定义的bug
问题描述：(define f (lambda () (f)))
在语法分析阶段analyze函数中，
先生成f的环境结点，指定一个未初始化的值
然后analyze f的具体定义生成ast,初始化f
但是...在递归的lambda内分析f时，f是还未初始化的，因此不知道如何处理这种情况。

2011.9.6
修复递归定义的bug
解决方法：
在analyze中加入对末初始化值的处理。不再是直接生成procedure的调用的代码，而是生成 （获得procedure的代码，然后调用） 的代码
在(lambda () (f))中，如果f是末初始化的，
不再取其值，而是取环境结点。虚拟机中加入了一条UNINIT_REF指令。
在代码生成中，先PUSH环境结点，再UNINIT_REF，如此，在运行时期就可以得到已初始化的f
子问题：对于生成末初始化值的procedure，由于语法分析阶段得不到procedure，所以上面的解决方案是推迟到了运行期
但是语法分析阶段procedure没初始化，就无法生成形参实参绑定的代码。
于是加了一条指令BIND,运行期动态绑定参数

2011.9.8-2011.7.11
实现scheme语言的"卫生宏"
实现方法是一言以蔽之：在当前环境“展开”宏，在宏定义的环境进行计算
宏定义阶段：
syntax-rules生成一个syntax，这个syntax包括三个成员，模式，模板，宏定义环境
模板这个时候都是不编码的，是外部表示的形式
宏使用阶段：
如果是宏，匹配到了某个模式，则编译模板。编译过程特殊处理，若变量是宏的参数，则在
当前环境中查找变量，否则，在宏定义环境中查找变量。这就是所谓的在当前环境“展开”宏，
在宏定义的环境进行计算。
