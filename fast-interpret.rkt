#lang racket

(define (sr-extend* sr v*)
  (cons (sr v*)))

(define (deep-fetch sr i j)
  (if (= i 0)
      (activation-frame-argument sr j)
      (deep-fetch (environment-next sr) (- i 1) j)))

(define (activation-frame-argument sr j)
  (vector-ref (car sr) j))

(define (environment-next sr)
  (cdr sr))

(define (deep-update! sr i j v)
  (if (= i 0)
      (set-activation-frame-argument! sr j v)
      (deep-update! (environment-next sr) (- i 1) j v)))

(define (set-activation-frame-argument! sr j v)
  (vector-set! (car sr) j v))

(define (r-extend* r n*)
  (cons n* r))

(define (local-variable? r i n)
  (and (pair? r)
       (let scan ((names (car r))
                  (j 0))
         (cond ((pair? names)
                (if (eq? n (car names))
                    `(local ,i . ,j)
                    (scan (cdr names) (+ 1 j))))
               ((null? names)
                (local-variable? (cdr r) (+ i 1) n))
               ((eq? n names) `(local ,i . ,j))))))

(define (atom? v) (not (pair? v)))

(define (meaning e r)
  (if (atom? e)
      (if (symbol? e) (meaning-reference e r)
          (meaning-quotation e r))
      (case (car e)
        ((quote) (meaning-quotation (cadr e) r))
        ((lambda) (meaning-abstraction (cadr e) (cddr e) r))
        ((if) (meaning-alternative (cadr e) (caddr e) (cadddr e) r))
        ((begin) (meaning-sequence (cdr e) r))
        ((set!) (meaning-assignment (cadr e) (caddr e) r))
        (else (meaning-application (car e) (cdr e) r)))))

(define (meaning-quotation v r)
  (lambda (sr k)
    (k v)))

(define (meaning-alternative e1 e2 e3 r)
  (let ((m1 (meaning e1 r))
        (m2 (meaning e2 r))
        (m3 (meaning e3 r)))
    (lambda (sr r)
      (m1 sr (lambda (v)
               ((if v m2 m3) sr k))))))

(define (meaning-sequence e+ r)
  (if (pair? e+)
      (if (pair? (cdr e+))
          (meaning*-multiple-sequence (car e+) (cdr e+) r)
          (meaning (car e+) r))
      (static-wrong "Illegal syntex: (begin)")))

(define (meaning*-multiple-sequence e e+ r)
  (let ((m1 (meaning e r))
        (m+ (meaning-sequence e+ r)))
    (lambda (sr k)
      (m1 sr (lambda (v)
               (m+ sr k))))))

(define (meaning-regular-application e e* r)
  (let* ((m (meaning e r))
         (m* (meaning* e* r (length e*))))
    (lambda (sr k)
      (m sr (lambda (f)
              (if (procedure? f)
                  (m* sr (lambda (v*)
                           (f v* k)))
                  (wrong "Not a function" f)))))))

(define (meaning* e* r size)
  (if (pair? e*)
      (meaning-some-arguments (car e*) (cdr e*) r size)
      (meaning-no-argument r size)))

(define (meaning-no-argument r size)
  (let ((size+1 (+ size 1)))
    (lambda (sr k)
      (let ((v* (allocate-activation-frame size+1)))
        (k v*)))))

(define (meaning-some-arguments e e* r size)
  (let ((m (meaning e r))
        (m* (meaning* e* r size))
        (rank (- size (+ (lengith e*) 1))))
    (lambda (sr k)
      (m sr (lambda (v)
              (m* sr (lambda (v*)
                       (set-activation-frame-argument! v* rank v)
                       (k v*))))))))

(define (meaning-fix-abstraction n* e+ r)
  (let* ((arity (length n*))
         (arity+1 (+ arity 1))
         (r2 (r-extend* r n*))
         (m+ (meaning-sequence e+ r2)))
    (lambda (sr k)
      (k (lambda (v* k1)
           (if (= (activation-frame-argument-length v*) arity+1)
               (m+ (sr-extend* sr v*) k1)
               (wrong "Incorrect arity")))))))

(define (compute-kind r n)
  (or (local-variable? r 0 n)
      (global-variable? g.current n)
      (global-variable? g.init n)))

(define (global-variable? g n)
  (let ((var assq n g))
    (and (pair? var) (cdr var))))

(define (g.current-extend! n)
  (let ((level (length g.current)))
    (set! g.current (cons (cons n `(global . ,level)) g.current))
    level))

(define (g.init-extend! n)
  (let ((level (length g.init)))
    (set! g.init (cons (cons n `(predefined . ,level)) g.init))
    level))

(define sg.current (make-vector 100))
(define sg.init (make-vector 100))
(define (global-fetch i)
  (vector-ref sg.current i))
(define (global-update! i v)
  (vector-set! sg.current i v))
(define (predefined-fetch i)
  (vector-ref sg.init i))

(define (g.current-initialize! name)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((global)
           (vector-set! sg.current (cdr kind) 'undef))
          (else (format "Wrong redefinition" name)))
        (let ((index (g.current-extend! name)))
          (vector-set! sg.current index 'undef))))
  name)

(define (g.init-initialize! name value)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((predefined)
           (vector-set! sg.init (cdr kind) value))
          (else (format "Wrong redifinition" name)))
        (let ((index (g.init-extend! name)))
          (vector-set! sg.init index value))))
  name)

(define (meaning-reference n r)
  (let ((kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)))
             (if (= i 0)
                 (lambda (sr k)
                   (k (activation-frame-argument sr j)))
                 (lambda (sr k)
                   (k (deep-fetch sr i j))))))
          ((global)
           (let ((i (cdr kind)))
             (if (eq? (global-fetch i) 'undefined)
                 (lambda (sr k)
                   (let ((v (global-fetch i)))
                     (if (eq? v 'undefined)
                         (display "Uninitialized variable" n)
                         (k v))))
                 (lambda (sr k)
                   (k (global-fetch i))))))
          ((predefined)
           (let* ((i (cdr kind))
                  (value (predefined-fetch i)))
             (lambda (sr k)
               (k value)))))
        (display "No such variable" n))))

(define (meaning-assignment n e r)
  (let ((m (meaning e r))
        (kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)))
             (if (= i 0)
                 (lambda (sr k)
                   (m sr (lambda (v)
                           (k (set-activation-frame-argument!
                               sr j v)))))
                 (lambda (sr k)
                   (m sr (lambda (v)
                           (k (deep-update! sr i j v))))))))
          ((global)
           (let ((i (cdr kind)))
             (lambda (sr k)
               (m sr (lambda (v)
                       (k (global-update! i v)))))))
          ((predefined)
           (display "Immutable predefined variable" n)))
        (static-wrong "No such variable" n))))

(define static-wrong 'wait)
(set! static-wrong
      (lambda (message . culprits)
        (display '(*static-error* ,message . ,culprits)) (newline)
        (lambda (sr k)
          (apply wrong message culprits))))

(define r.init '())
(define sr.init '())
(define (chapter61-interpreter)
  (define (compile e) (meaning e r.init))
  (define (run c) (c sr.init display))
  (define (toplevel)
    (run (compile (read)))
    (toplevel))
  (toplevel))
          
(definitial t #t)
(definitial f #f)
(definitial nil '())
(defprimitive cons cons 2)
(defprimitive car car 1)
(definitial call/cc
  (let* ((arity 1)
         (arity+1 (+ arity 1)))
    (lambda (v* k)
      (if (= arity+1 (activation-frame-argument-length v*))
          ((activation-frame-argument v* 0)
           (let ((frame (allocate-activation-frame (+ 1 1))))
             (set-activation-frame-argument!
              frame 0
              (lambda (values kk)
                (if (= (activation-frame-argument-length values)
                       arity+1)
                    (k (activation-frame-argument values 0))
                    (wrong "Incorrect arity" 'contination)))))
             frame)
           k)
      (wrong "Incorrect arity" 'call/cc))))

(define (meaning-dotted-abstraction n* n e+ r)
  (let* ((arity (length n*))
         (arity+1 (+ arity 1))
         (r2 (r-extend* r (append n* (list n))))
         (m+ (meaning-sequence e+ r2)))
    (lambda (sr k)
      (k (lambda (v* k1)
           (if (>= (activation-frame-argument-length v*) arity+1)
               (begin (listify! v* arity)
                      (m+ (sr-extend* sr v*) k1))
               (wrong "Incorrect arity")))))))

(define (listify! v* arity)
  (let loop ((index (- (activation-frame-argument-length v*) 1))
             (result '()))
    (if (= arity index)
        (set-activation-frame-argument! v* arity result)
        (loop (- index 1)
              (cons (activation-frame-argument v* (- index 1))
                    result)))))

(define (meaning-abstraction nn* e+ r)
  (let parse ((n* nn*)
              (regular '()))
    (cond
      ((pair? n*) (parse (cdr n*) (cons (car n*) regular)))
      ((null? n*) (meaning-fix-abstraction nn* e+ r))
      (else (meaning-dotted-abstraction (reverse regular) n* e+ r)))))