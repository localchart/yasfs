(define (OP_MOVE A B) (format "R(~a) := R(~a)" A B))
(define (OP_LOADK A Bx) (format "R(~a) := Kst(~a)" A Bx))
(define (OP_LOADKX A) (format "R(~a) := Kst(extra arg)" A))
(define (OP_LOADBOOL A B C) (format "R(~a) := (Bool)~a; if (~a) pc++" A B C))
(define (OP_LOADNIL	A B)	(format "R(~a), R(~a), ..., R(~a) := nil" A (+ A 1) (+ A B)))
(define (OP_GETUPVAL	A B)	(format "R(~a) := UpValue[~a]" A B))
(define (OP_GETTABUP	A B C)	(format "R(~a) := UpValue[~a][RK(~a)]" A B C))
(define (OP_GETTABLE	A B C)	(format "R(~a) := R(~a)[RK(~a)]" A B C))
(define (OP_SETTABUP	A B C)	(format "UpValue[~a][RK(~a)] := RK(~a)" A B C))
(define (OP_SETUPVAL	A B)	(format "UpValue[~a] := R(~a)" A B))
(define (OP_SETTABLE	A B C)	(format "R(~a)[RK(~a)] := RK(~a)" A B C))
(define (OP_NEWTABLE	A B C)	(format "R(~a) := {} (size = ~a,~a)" A B C))
(define (OP_SELF	A B C)	(format "R(~a) := R(~a); R(~a) := R(~a)[RK(~a)]" (+ A 1) B A B C))
(define (OP_ADD	A B C)	(format "R(~a) := RK(~a) + RK(~a)" A B C))
(define (OP_SUB	A B C)	(format "R(~a) := RK(~a) - RK(~a)" A B C))
(define (OP_MUL	A B C)	(format "R(~a) := RK(~a) * RK(~a)" A B C))
(define (OP_MOD	A B C)	(format "R(~a) := RK(~a) % RK(~a)" A B C))
(define (OP_POW	A B C)	(format "R(~a) := RK(~a) ^ RK(~a)" A B C))
(define (OP_DIV	A B C)	(format "R(~a) := RK(~a) / RK(~a)" A B C))
(define (OP_IDIV	A B C)	(format "R(~a) := RK(~a) // RK(~a)" A B C))
(define (OP_BAND	A B C)	(format "R(~a) := RK(~a) & RK(~a)" A B C))
(define (OP_BOR	A B C)	(format "R(~a) := RK(~a) | RK(~a)" A B C))
(define (OP_BXOR	A B C)	(format "R(~a) := RK(~a) ~ RK(~a)" A B C))
(define (OP_SHL	A B C)	(format "R(~a) := RK(~a) << RK(~a)" A B C))
(define (OP_SHR	A B C)	(format "R(~a) := RK(~a) >> RK(~a)" A B C))
(define (OP_UNM	A B)	(format "R(~a) := -R(~a)" A B))
(define (OP_BNOT	A B)	(format "R(~a) := ~R(~a)" A B))
(define (OP_NOT	A B)	(format "R(~a) := not R(~a)" A B))
(define (OP_LEN	A B)	(format "R(~a) := length of R(~a)" A B))
(define (OP_CONCAT	A B C)	(format "R(~a) := R(~a).. ... ..R(~a)" A B C))
(define (OP_JMP	A sBx)	(format "pc+=~a; if (~a) close all upvalues >= R(~a)" sBx A (- A 1)))
(define (OP_EQ	A B C)	(format "if ((RK(~a) == RK(~a)) ~= ~a) then pc++" B C A))
(define (OP_LT	A B C)	(format "if ((RK(~a) <  RK(~a)) ~= ~a) then pc++" B C A))
(define (OP_LE	A B C)	(format "if ((RK(~a) <= RK(~a)) ~= ~a) then pc++" B C A))
(define (OP_TEST	A C)	(format "if not (R(~a) <=> ~a) then pc++" A C))
(define (OP_TESTSET	A B C)	(format "if (R(~a) <=> ~a) then R(~a) := R(~a) else pc++" B C A B))
(define (OP_CALL	A B C)	(format "R(~a), ... ,R(~a) := R(~a)(R(~a), ... ,R(~a))" A (- (+ A C) 2) A (+ A 1) (- (+ A B) 1)))
(define (OP_TAILCALL	A B C)	(format "return R(A)(R(A+1), ... ,R(A+B-1))" A (+ A 1) (+ (+ A B) 1)))
(define (OP_RETURN	A B)	(format "return R(~a), ... ,R(~a)" A (- (+ A B) 2)))
(define (OP_FORLOOP	A sBx)	(format "R(~a)+=R(~a);
			if R(~a) <?= R(~a) then { pc+=~a; R(~a)=R(~a) }" A (+ A 2) A (+ A 1) sBx (+ A 3) A))
(define (OP_FORPREP	A sBx)	(format "R(~a)-=R(~a); pc+=~a" A (+ A 2) sBx))
(define (OP_TFORCALL	A C)	(format "R(~a), ... ,R(~a) := R(~a)(R(~a), R(~a));" (+ A 3) (+ A C 2) A (+ A 1) (+ A 2)))
(define (OP_TFORLOOP	A sBx)	(format "if R(~a) ~= nil then { R(~a)=R(~a); pc += ~a }" (+ A 1) A (+ A 1) sBx))
(define (OP_SETLIST	A B C)	(format "R(~a)[~a*FPF+i] := R(~a+i), 1 <= i <= ~a" A (- C 1) A B))
(define (OP_CLOSURE	A Bx)	(format "R(~a) := closure(KPROTO[~a])" A Bx))
(define (OP_VARARG	A B)	(format "R(~a), R(~a), ..., R(~a) = vararg" A (+ A 1) (- (+ A B) 2)))
(define (OP_EXTRAARG	Ax)	(format "extra (larger) argument for previous opcode ~a" Ax))
